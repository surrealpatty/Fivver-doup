{"version":3,"sources":["../../../src/middlewares/auth.ts"],"sourcesContent":["import { Request, Response, NextFunction } from 'express';\r\nimport jwt from 'jsonwebtoken';\r\nimport config from '../config/config'; // Importing config for JWT_SECRET and JWT_EXPIRATION\r\n\r\nconst JWT_SECRET: string = config.JWT_SECRET;\r\nconst JWT_EXPIRATION: string = config.JWT_EXPIRATION || '1h';\r\n\r\n// Define the expected JWT Payload structure\r\ninterface JwtPayload {\r\n  id: string; // Keep as string for typical JWT payloads\r\n  [key: string]: any; // Allow for other properties in the JWT payload\r\n}\r\n\r\n// Extend Express' Request interface to include userId\r\ninterface AuthRequest extends Request {\r\n  userId?: string; // This is where the userId from JWT will be stored\r\n}\r\n\r\n// The `verifyToken` middleware to check JWT in headers\r\nexport const verifyToken = (\r\n  req: AuthRequest,  // Use the custom AuthRequest type\r\n  res: Response,\r\n  next: NextFunction\r\n): Response<any> | void => {\r\n  const token = req.headers['authorization']?.split(' ')[1];\r\n\r\n  if (!token) {\r\n    return res.status(403).json({ message: 'No token provided' });\r\n  }\r\n\r\n  jwt.verify(token, JWT_SECRET, (err, decoded) => {\r\n    if (err) {\r\n      return res\r\n        .status(401)\r\n        .json({ message: 'Unauthorized', error: err.message });\r\n    }\r\n\r\n    // Handle decoding and verifying the JWT payload\r\n    if (decoded && typeof decoded === 'object' && 'id' in decoded) {\r\n      const decodedToken = decoded as JwtPayload;\r\n\r\n      // Cast decodedToken.id to string (if necessary)\r\n      req.userId = String(decodedToken.id); // Explicitly cast to string\r\n\r\n      return next();\r\n    } else {\r\n      return res.status(401).json({ message: 'Invalid token' });\r\n    }\r\n  });\r\n};\r\n\r\n// Generate a token for the user\r\nexport const generateToken = (userId: string): string => {\r\n  return jwt.sign({ id: userId }, JWT_SECRET, {\r\n    expiresIn: JWT_EXPIRATION,\r\n  });\r\n};\r\n\r\n// Example middleware to authenticate the user using the token\r\nexport const authenticateJWT = (\r\n  req: AuthRequest,  // Use the custom AuthRequest type here as well\r\n  res: Response,\r\n  next: NextFunction\r\n) => {\r\n  // Check if userId exists in request\r\n  if (!req.userId) {\r\n    return res.status(403).json({ message: 'No valid token or userId found.' });\r\n  }\r\n  next();\r\n};\r\n"],"names":["authenticateJWT","generateToken","verifyToken","JWT_SECRET","config","JWT_EXPIRATION","req","res","next","token","headers","split","status","json","message","jwt","verify","err","decoded","error","decodedToken","userId","String","id","sign","expiresIn"],"mappings":";;;;;;;;;;;IA2DaA,eAAe;eAAfA;;IAPAC,aAAa;eAAbA;;IAjCAC,WAAW;eAAXA;;;qEAlBG;+DACG;;;;;;AAEnB,MAAMC,aAAqBC,eAAM,CAACD,UAAU;AAC5C,MAAME,iBAAyBD,eAAM,CAACC,cAAc,IAAI;AAcjD,MAAMH,cAAc,CACzBI,KACAC,KACAC;IAEA,MAAMC,QAAQH,IAAII,OAAO,CAAC,gBAAgB,EAAEC,MAAM,IAAI,CAAC,EAAE;IAEzD,IAAI,CAACF,OAAO;QACV,OAAOF,IAAIK,MAAM,CAAC,KAAKC,IAAI,CAAC;YAAEC,SAAS;QAAoB;IAC7D;IAEAC,qBAAG,CAACC,MAAM,CAACP,OAAON,YAAY,CAACc,KAAKC;QAClC,IAAID,KAAK;YACP,OAAOV,IACJK,MAAM,CAAC,KACPC,IAAI,CAAC;gBAAEC,SAAS;gBAAgBK,OAAOF,IAAIH,OAAO;YAAC;QACxD;QAEA,gDAAgD;QAChD,IAAII,WAAW,OAAOA,YAAY,YAAY,QAAQA,SAAS;YAC7D,MAAME,eAAeF;YAErB,gDAAgD;YAChDZ,IAAIe,MAAM,GAAGC,OAAOF,aAAaG,EAAE,GAAG,4BAA4B;YAElE,OAAOf;QACT,OAAO;YACL,OAAOD,IAAIK,MAAM,CAAC,KAAKC,IAAI,CAAC;gBAAEC,SAAS;YAAgB;QACzD;IACF;AACF;AAGO,MAAMb,gBAAgB,CAACoB;IAC5B,OAAON,qBAAG,CAACS,IAAI,CAAC;QAAED,IAAIF;IAAO,GAAGlB,YAAY;QAC1CsB,WAAWpB;IACb;AACF;AAGO,MAAML,kBAAkB,CAC7BM,KACAC,KACAC;IAEA,oCAAoC;IACpC,IAAI,CAACF,IAAIe,MAAM,EAAE;QACf,OAAOd,IAAIK,MAAM,CAAC,KAAKC,IAAI,CAAC;YAAEC,SAAS;QAAkC;IAC3E;IACAN;AACF"}