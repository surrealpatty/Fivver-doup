{"version":3,"sources":["../../../src/test/orderController.ts"],"sourcesContent":["import { Request, Response, NextFunction } from 'express';\r\nimport jwt from 'jsonwebtoken';\r\nimport { UserPayload } from '../types/index'; // Correctly import UserPayload from the types directory\r\n\r\n// Ensure JWT_SECRET is available in the environment variables\r\nconst jwtSecret = process.env.JWT_SECRET as string; // Assert type as string\r\n\r\nif (!jwtSecret) {\r\n  console.error('JWT_SECRET is not set. Authentication will fail.');\r\n}\r\n\r\n// Extend the Request interface to include user\r\ninterface AuthRequest extends Request {\r\n  user?: UserPayload; // Ensure TypeScript knows that req.user is of type UserPayload\r\n}\r\n\r\n/**\r\n * Middleware to authenticate the token provided in the Authorization header.\r\n * If the token is valid, the decoded payload is attached to `req.user`.\r\n */\r\nexport const authenticateToken = (\r\n  req: AuthRequest,\r\n  res: Response,\r\n  next: NextFunction\r\n): void => {\r\n  try {\r\n    // Extract token from the Authorization header\r\n    const authHeader = req.headers['authorization'];\r\n    const token = authHeader?.startsWith('Bearer ') ? authHeader.split(' ')[1] : undefined;\r\n\r\n    if (!token) {\r\n      res.status(401).json({ message: 'Access denied, no token provided.' });\r\n      return;\r\n    }\r\n\r\n    // Verify the token\r\n    const decoded = jwt.verify(token, jwtSecret) as UserPayload;\r\n\r\n    // Attach the decoded payload to req.user\r\n    req.user = decoded;\r\n\r\n    // Proceed to the next middleware or route handler\r\n    next();\r\n  } catch (error: unknown) {\r\n    if (error instanceof Error) {\r\n      console.error('Authentication error:', error.message);\r\n      res.status(403).json({ message: 'Invalid or expired token.' });\r\n      return;\r\n    }\r\n\r\n    // Fallback for cases when the error is not of type `Error`\r\n    console.error('Unexpected error during authentication:', error);\r\n    res.status(500).json({ message: 'Internal server error.' });\r\n  }\r\n};\r\n\r\n/**\r\n * Middleware to check if the user is authenticated.\r\n * It uses `authenticateToken` and adds additional checks if needed.\r\n */\r\nexport const checkAuth = (\r\n  req: AuthRequest,\r\n  res: Response,\r\n  next: NextFunction\r\n): void => {\r\n  authenticateToken(req, res, () => {\r\n    // Add any additional checks if needed\r\n    if (req.user) {\r\n      next(); // If authenticated, proceed to the next route handler\r\n    } else {\r\n      res.status(401).json({ message: 'Authentication failed.' });\r\n    }\r\n  });\r\n};\r\n"],"names":["authenticateToken","checkAuth","jwtSecret","process","env","JWT_SECRET","console","error","req","res","next","authHeader","headers","token","startsWith","split","undefined","status","json","message","decoded","jwt","verify","user","Error"],"mappings":";;;;;;;;;;;IAoBaA,iBAAiB;eAAjBA;;IAwCAC,SAAS;eAATA;;;qEA3DG;;;;;;AAGhB,8DAA8D;AAC9D,MAAMC,YAAYC,QAAQC,GAAG,CAACC,UAAU,EAAY,wBAAwB;AAE5E,IAAI,CAACH,WAAW;IACdI,QAAQC,KAAK,CAAC;AAChB;AAWO,MAAMP,oBAAoB,CAC/BQ,KACAC,KACAC;IAEA,IAAI;QACF,8CAA8C;QAC9C,MAAMC,aAAaH,IAAII,OAAO,CAAC,gBAAgB;QAC/C,MAAMC,QAAQF,YAAYG,WAAW,aAAaH,WAAWI,KAAK,CAAC,IAAI,CAAC,EAAE,GAAGC;QAE7E,IAAI,CAACH,OAAO;YACVJ,IAAIQ,MAAM,CAAC,KAAKC,IAAI,CAAC;gBAAEC,SAAS;YAAoC;YACpE;QACF;QAEA,mBAAmB;QACnB,MAAMC,UAAUC,qBAAG,CAACC,MAAM,CAACT,OAAOX;QAElC,yCAAyC;QACzCM,IAAIe,IAAI,GAAGH;QAEX,kDAAkD;QAClDV;IACF,EAAE,OAAOH,OAAgB;QACvB,IAAIA,iBAAiBiB,OAAO;YAC1BlB,QAAQC,KAAK,CAAC,yBAAyBA,MAAMY,OAAO;YACpDV,IAAIQ,MAAM,CAAC,KAAKC,IAAI,CAAC;gBAAEC,SAAS;YAA4B;YAC5D;QACF;QAEA,2DAA2D;QAC3Db,QAAQC,KAAK,CAAC,2CAA2CA;QACzDE,IAAIQ,MAAM,CAAC,KAAKC,IAAI,CAAC;YAAEC,SAAS;QAAyB;IAC3D;AACF;AAMO,MAAMlB,YAAY,CACvBO,KACAC,KACAC;IAEAV,kBAAkBQ,KAAKC,KAAK;QAC1B,sCAAsC;QACtC,IAAID,IAAIe,IAAI,EAAE;YACZb,QAAQ,sDAAsD;QAChE,OAAO;YACLD,IAAIQ,MAAM,CAAC,KAAKC,IAAI,CAAC;gBAAEC,SAAS;YAAyB;QAC3D;IACF;AACF"}